#
# IonQ, Inc., Copyright (c) 2024,
# All rights reserved.
# Use in source and binary forms of this software, without modification,
# is permitted solely for the purpose of activities associated with the IonQ
# Hackathon at Quantum Korea hosted by SKKU at Hotel Samjung and only during the
# June 21-23, 2024 duration of such event.
#
from abc import ABC, abstractmethod
from copy import deepcopy
from ionqvision.ansatze import VariationalAnsatz
from ionqvision.quantum_execution import QiskitBackend, QiskitEvaluator
from numbers import Number
from qiskit import QuantumCircuit
from qiskit.providers.backend import Backend as BuiltInQiskitBackend
from typing import List, Sequence, Tuple

import numpy as np
import sympy as sp


class QuantumFunction(ABC):
    r"""
    An abstract class used to model the computational atoms serving as building
    blocks for the IonQ framework for differentiable quantum computations.

    This class models the sub-category of smooth real-valued functions that are
    defined over some hypercube $[0, 2\pi]^n$ and are given by a composition
    $f = h \circ g$, where $g\colon \mathbb{R}^n \to \mathbb{C}^{2m}$ maps
    variational ansatz parameters to vectors in a high-dimensional Hilbert space
    described by the tensor product of qubit spaces, and
    $h\colon \mathbb{C}^{2m} \to \mathbb{R}$ encapsulates the classical
    post-processing required to compute the function value upon measuring the
    bound ansatz.

    This class is equipped with the structure of an additive monoidal category
    $\mathcal{C}$ that is generated by simple objects and is enriched over
    $\mathbb{R}$. In addition, this category is equipped with a natural
    embedding $\mathbb{R} \hookrightarrow \mathcal{C}$. Since this category
    models a function category, the additive and monoidal operations are simply
    point-wise sums and products.

    In English, this means we can perform arithmetic operations on
    :class:`.QuantumFunction` objects, so that the following syntax is
    completely legal tender::

        >>> from ionqvision.ansatze import VariationalAnsatz
        >>> from ionqvision.quantum_functions import IsingEnergy
        >>> from qiskit.circuit import Parameter
        >>> from qiskit.quantum_info import SparsePauliOp
        >>> t, r = Parameter("t"), Parameter("r")
        >>> ansatz = VariationalAnsatz(2)
        >>> _ = ansatz.rx(r, 0)
        >>> _ = ansatz.ry(t, 1)
        >>> e1 = IsingEnergy(SparsePauliOp("ZI", coeffs=1), ansatz)
        >>> e2 = IsingEnergy(SparsePauliOp("ZI", coeffs=1), ansatz)
        >>> -e2 + e1 * e2 - 3*e1 + 1 == e1
        False


    And also::    
    
        >>> energy = IsingEnergy(SparsePauliOp("ZI", coeffs=1), ansatz)
        >>> f = 1 - energy * energy
        0.72154

    This class serves as a template for developers intending to build new
    computational atoms. It models a mathematical (scalar) function of
    variational circuit parameters; that is, :meth:`fun` maps a vector
    ``param_vals`` of variational circuit parameter values to a scalar.

    The design is such that the quantum execution is separate from the classical.
    Therefore, in order to use the public-facing method :meth:`fun`, the
    developer must implement two methods:

    1. :meth:`_prepare_quantum_execution_fun`, which accepts a list of values
    for the variational circuit parameters and returns a list of bound circuits
    obtained from the :class:`.VariationalAnsatz` ``ansatz`` by assigning
    parameters and applying any desired circuit transformations, such as
    appending a change-of-basis sub-circuit.
    
    2. :meth:`_fun`, which accepts a list of measurements corresponding to the
    circuits prepared by :meth:`_prepare_quantum_execution_fun` and implements
    all the classical post-processing required to obtain the result of the
    quantum function evaluation; in most cases, this post-processing computes
    some sort of expectation value.

    The developer must similarly implement
    :meth:`_prepare_quantum_execution_grad` and :meth:`_grad`, using the same
    signatures as the methods above. In particular, if
    ``self.is_differentiable`` is ``True``, then every solver in this package
    assumes :meth:`grad` is fully implemented.

    .. NOTE::

        :class:`.QuantumFunction` inherits from :class:`ABC`, so it cannot be
        instantiated directly. Similarly, attempting to instantiate a subclass
        without explicitly implementing all the required `abstractmethod`'s
        results in a `TypeError`. On the flip side, the public-facing methods
        :meth:`fun` and :meth`grad` should *not* be overriden.
    """
    def __init__(self, ansatz: VariationalAnsatz):
        self._ansatz = ansatz
        self._is_differentiable = True
        self._fun_symb_cache = None
        self._grad_symb_cache = None
        self._grad_symb_cache_param_order = None
        self._latest_param_vals = None

    def __call__(self, param_vals, backend=None, shots=1000, cvar_alpha=1.0):
        """
        Convenience method serving as an alias to :meth:`fun`; for an
        explanation of the inputs, refer to the documentation in :meth:`fun`.
        """
        return self.fun(param_vals, backend, shots, cvar_alpha)

    def __add__(self, other):
        """
        Add two :class:`.QuantumFunction` instances to produce a
        :class:`.QuantumFunction` representing the sum of ``self`` and
        ``other``.

        If ``other`` is any ``numbers.Number``, it is coerced into a
        :class:`.QuantumFunction` instance using the
        :class:`.ConstantQuantumFunction`.
        """
        if not isinstance(other, (Number, QuantumFunction)):
            raise ValueError("other must be a Number or a QuantumFunction instance")
        if isinstance(other, Number):
            from .constant_quantum_function import ConstantQuantumFunction
            other = ConstantQuantumFunction(self.ansatz, other)
        if self.ansatz != other.ansatz or self.ansatz.get_param_order() != other.ansatz.get_param_order():
            raise ValueError("self and other must use the same ansatz, with params in the same order")
        from .quantum_function_sum import QuantumFunctionSum
        return QuantumFunctionSum(self, other)

    def __radd__(self, other):
        """
        Right add; implemented to ensure addition is commutative.
        """
        return self + other

    def __eq__(self, other):
        """
        Test equality by checking the symbolic expressions.

        .. NOTE::

            Testing equality triggers a symbolic computation, which may be slow.
        """
        from .hybrid_function import HybridFunction
        if not isinstance(other, (HybridFunction, Number, QuantumFunction)):
            raise TypeError(f"Comparison is not supported between {type(self)} and {type(other)}.")
        if isinstance(other, Number):
            from .constant_quantum_function import ConstantQuantumFunction
            other = ConstantQuantumFunction(other)
        iseq = self.ansatz == other.ansatz and self.ansatz.symbols == other.ansatz.symbols
        iseq &= bool((self.fun_symb() - other.fun_symb()).simplify().is_zero)
        return iseq

    def __mul__(self, other):
        """
        Compute the product of self and other.
        """
        if not isinstance(other, (Number, QuantumFunction)):
            raise ValueError("other must be a Number or a QuantumFunction instance")
        if isinstance(other, Number):
            from .constant_quantum_function import ConstantQuantumFunction
            other = ConstantQuantumFunction(self.ansatz, other)
        if self.ansatz != other.ansatz or self.ansatz.get_param_order() != other.ansatz.get_param_order():
            raise ValueError("self and other must use the same ansatz, with params in the same order")
        from .quantum_function_product import QuantumFunctionProduct
        return QuantumFunctionProduct(self, other)

    def __rmul__(self, other):
        """
        Right multiplication; implemented to ensure commutative products.
        """
        return self * other

    def __neg__(self):
        """
        Negative of ``self``; equivalent to ``-1 * self``.
        """
        return -1 * self

    def __pow__(self, other):
        """
        Raise function to a given integral power by consecutive multiplication.
        """
        if not isinstance(other, int):
            raise TypeError(f"unsupported operand type(s) for ** or pow(): {type(self)} and {type(other)}")

        ret = deepcopy(self)
        for _ in range(other-1):
            ret *= self
        return ret

    def __sub__(self, other):
        """
        Subtraction defined by adding the additive inverse.
        """
        return self + -other

    def __rsub__(self, other):
        """
        Right substraction using
        """
        return -self + other

    def _eval_symb(self, f, x):
        return f.evalf(subs={theta: x[k] for k, theta in enumerate(self.ansatz.symbols)})

    @abstractmethod
    def _prepare_quantum_execution_fun(self, param_vals: Sequence[float]) -> List[QuantumCircuit]:
        """
        Get a list of bound quantum circuits that need to be executed in order
        to evaluate ``self._fun``.
        """
        pass

    @abstractmethod
    def _fun(self, measurements: List[dict], cvar_alpha: float) -> Tuple[float, float]:
        """
        This private method implements the computation of the quantum function
        value, as some weighted average of circuit measurements.

        .. NOTE::

            This method is purely classical and *cannot* require any sort of
            execution on a quantum backend target.

        INPUT:

            - ``measurements`` -- a list of measurements corresponding to the
              execution of the result of :meth:`_prepare_quantum_execution_fun`
              on a quantum ``backend``
            - ``cvar_alpha`` -- parameter for use in computing the CVaR
              expectation value; for details,
              see :meth:`ionqvision.utils.cvar_moments`

        OUTPUT:

            A tuple ``(fun_val, var)`` where ``fun_val`` is a float and
            ``var`` is the variance of the function evaluation: it can be a
            ``float`` or ``np.nan``.
        """
        pass

    @abstractmethod
    def _prepare_quantum_execution_grad(self, param_vals: Sequence[float]) -> List[QuantumCircuit]:
        """
        Get a list of bound quantum circuits that need to be executed in order
        to evaluate ``self._grad``.
        """
        pass

    @abstractmethod
    def _grad(self, measurements: List[dict], cvar_alpha: float) -> Tuple[Sequence[float], Sequence[float]]:
        """
        This private method implements the computation of the quantum function's
        gradient as some weighted average of circuit measurements.

        .. NOTE::

            This method is purely classical and *cannot* require any sort of
            execution on a quantum backend target.

        INPUT:

            - ``measurements`` -- a list of measurements corresponding to the
              execution of the result of :meth:`_prepare_quantum_execution_fun`
              on a quantum ``backend``
            - ``cvar_alpha`` -- parameter for use in computing the CVaR
              expectation value; for details,
              see :meth:`ionqvision.utils.cvar_moments`

        OUTPUT:

            A tuple ``(grad_val, var)`` where ``grad_val`` is an array and
            ``var`` is the variance of the gradient evaluation.
        """
        pass

    def _fun_symb(self, param_vals: Sequence[float] | None = None) -> sp.Expr | float:
        """
        Compute an analytical expression for :meth:`fun`.

        If the optional ``param_vals`` are passed, the symbolic expression is
        evaluated with ``param_vals`` in place of the free symbols.
        """
        pass

    def fun(
            self,
            param_vals: Sequence[float],
            backend: BuiltInQiskitBackend | None = None,
            shots: int = 1000,
            cvar_alpha: float = 1.0,
            metadata: bool = False
        ) -> float | Tuple[float, float]:
        """
        Evaluate the quantum function upon substituting ``param_vals`` in
        place of the variational parameters in ``self.ansatz``.

        The ``cvar_alpha`` is a float in ``[0, 1]`` that controls the
        computation of the Conditional Value at Risk (CVaR) expectation value;
        for details, see :meth:`ionqvision.utils.cvar_moments`.
        """
        evaluator = QiskitEvaluator(QiskitBackend(backend))
        res, data = evaluator.eval(self, "fun", param_vals, shots, cvar_alpha)
        if metadata:
            return res, data
        return res

    def grad(
            self,
            param_vals: Sequence[float],
            backend: BuiltInQiskitBackend | None = None,
            shots: int = 1000,
            cvar_alpha: float = 1.0,
            metadata: bool = False
        ) -> Sequence[float] | Tuple[Sequence[float], Sequence[float]]:
        """
        Evaluate the gradient of :meth:`fun` with respect to the variational
        parameters in ``self.ansatz``, upon substituting ``param_vals`` in place
        of the circuit parameters.

        .. NOTE::

            See :meth:`fun` for an explanation of ``cvar_alpha``.
        """
        if not self.is_differentiable:
            raise NotImplementedError("Function is not differentiable! Gradient is not available...")
        evaluator = QiskitEvaluator(QiskitBackend(backend))
        res, data = evaluator.eval(self, "grad", param_vals, shots, cvar_alpha)
        if metadata:
            return res, data
        return res

    def fun_symb(self, param_vals: Sequence[float] | None = None) -> sp.Expr:
        """
        Get a symbolic SymPy expression for :meth:`fun` (with free symbols).

        Optionally evaluate the symbolic expression by substituting
        ``param_vals`` for ``self.ansatz.symbols``.
        """
        if self._fun_symb_cache is None:
            self._fun_symb_cache = self._fun_symb()

        if param_vals is None:
            return self._fun_symb_cache
        return self._eval_symb(self._fun_symb_cache, param_vals)

    def grad_symb(self, param_vals: Sequence[float] | None = None) -> Sequence[sp.Expr]:
        """
        Get a symbolic SymPy expression for :meth:`grad` by performing symbolic
        differentiation on the result of :meth:`fun_symb`.

        Optionally evaluate the symbolic expression by substituting
        ``param_vals`` for ``self.ansatz.symbols``.

        .. NOTE::

            The partial derivatives appear in the order determined by
            ``self.ansatz.symbols``.
        """
        if not self.is_differentiable:
            raise NotImplementedError("Gradient is not available...")
        if self._grad_symb_cache is None:
            self._grad_symb_cache = [sp.diff(self.fun_symb(), theta) for theta in self.ansatz.symbols]
            self._grad_symb_cache_param_order = self.ansatz.symbols
        if self.ansatz.symbols != self._grad_symb_cache_param_order:
            old_order, new_order = self._grad_symb_cache_param_order, self.ansatz.symbols
            self._grad_symb_cache = [self._grad_symb_cache[old_order.index(p)] for p in new_order]
            self._grad_symb_cache_param_order = new_order

        if param_vals is None:
            ret = self._grad_symb_cache
        else:
            ret = [self._eval_symb(partial, param_vals) for partial in self._grad_symb_cache]
        return sp.Matrix(ret).T

    def get_param_order(self):
        """
        Get a list specifying the order in which lists of parameter values are
        interpreted.
        """
        return self._ansatz.get_param_order()

    def set_param_order(self, param_list):
        """
        Set the order in which parameter values should be interpreted.

        .. NOTE::

            :class:`.QuantumFunction`'s that manage multiple ansatze, like
            :class:`.HamiltonianEnergy` are responsible for setting the
            parameter order for each ansatz / constituent.
        """
        self._ansatz.set_param_order(param_list)

    @property
    def ansatz(self) -> VariationalAnsatz:
        """
        Get the variational ansatz required by this :class:`QuantumObjective`.
        """
        return self._ansatz

    @property
    def is_differentiable(self):
        """
        Report whether :meth:`fun` is differentiable with respect to the
        parameters in the :class:`.VariationalAnsatz` ``self.ansatz``.
        """
        return self._is_differentiable

    @is_differentiable.setter
    def is_differentiable(self, is_diff):
        """
        Determine whether :meth:`fun` is differentiable with respect to the
        variational parameters in ``self.ansatz``.
        """
        self._is_differentiable = is_diff
